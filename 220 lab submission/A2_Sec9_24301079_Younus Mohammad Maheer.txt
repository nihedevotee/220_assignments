TASK1

public static String checkSimilar( Node building1, Node building2 ){
       
        Node temp1 =building1;
        Node temp2 =building2;

        while (temp1 != null && temp2 != null){
            if (!(temp1.elem.equals(temp2.elem))){
                return "Not Similar";
            }
            
        temp1=temp1.next;
        temp2=temp2.next;
        }
        if(temp1 != null || temp2 != null){
            return "Not Similar";
        }
         
        return "Similar";
    }


TASK2
public static int sumDist(Node head, Integer[] distArr) {
        int sum=0;
        Node temp=head;
        
        int count=0;
        int counter=0;
        while(temp !=null){
                count++;
                temp=temp.next;
        }
        temp=head;

        for (int i = 0; i < distArr.length; i++) {
            temp=head;
            counter=0;

            if(distArr[i]>count){
                continue;
            }
            else{
                while(counter!=distArr[i] && temp != null){
                    counter++;
                    temp=temp.next;
                }
                if(counter==distArr[i] && temp != null){
                    sum=sum+(int)temp.elem;
                }
            }
        }
        return sum;
    }

TASK3

    public static Node alternateMerge( Node head1, Node head2 ){
        Node temp1=head1;
        Node temp2=head2;
        Node next1;
        Node next2;

        while(temp1 != null && temp2 != null){
            next1=temp1.next;
            next2=temp2.next;

            temp1.next=temp2;
            temp2.next=next1;

            temp1=next1;
            temp2=next2;
        } 
        return head1;
    }

TASK4
// AssignmentTask4: ID Generator
public class AssignmentTask4{
   
    // Must Submit this method
    // After you're done coding submit only this method
    public static Node idGenerator(Node head1, Node head2, Node head3) {
        Node prev=null;
        Node t1=head1;
        Node temp=head1;
        Node t2=head2;
        Node t3=head3;
        //Node add= new Node (0);

        while(t1 != null){
            Node NN=t1.next;
            t1.next=prev;
            prev=t1;
            t1=NN;
        }
        //head1.next=null;
        head1=prev;

        while(temp.next != null){
            temp=temp.next;
        }

        while(t3 != null){
            int added=(Integer)t2.elem+(Integer)t3.elem;
            if (added >9){
                added=added %10;
            }
            Node add=new Node(added);
            //add=temp.next;
            temp.next=add;
            temp=temp.next;
            t2=t2.next;
            t3=t3.next;
        }
        return head1;
    }

TASK5
public static void sumOddAppend(Node dh) {
        Node temp=dh;
        int sum=0;

        while(temp.next != dh){
            if((int)temp.next.elem % 2 != 0){
                sum += (int) temp.next.elem;
                temp.next=temp.next.next;
            }
            else{
                temp=temp.next;
            }
            // if(temp.next==dh){
            //     temp=temp.next;
            // }
        }
        temp=dh;
        while (true){
            //Node dummy=temp;
            if(temp.next != dh){
                //Node NN=new Node(sum);
                temp=temp.next;
                //NN=temp.next;
                //break;
            }
            else{
                //temp=temp.next;
                Node NN=new Node(sum);
                temp.next=NN;
                // temp.next=NN;
                NN.next=dh;
                break;

            }
        }
        
    }

TASK6
public static void pairJoin(DNode dh1, DNode dh2) {
        DNode temp1=dh1.next;
        DNode temp2=dh2.next;
        DNode next1;
        DNode next2;

        while(temp1 != null  && temp2 != null){
            next1=temp1.next;
            next2=temp2.next;

            temp1.next=temp2;
            temp2.prev=temp1;

            temp2.next=next1;

            if (next1 != null) {
                next1.prev = temp2;
            }


            temp1=next1;
            temp2=next2;


        }
        DNode temp = dh1;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = dh1;
        dh1.prev = temp;
    }

TASK7
public static void rangeMove(DNode dh, int start, int end) {
        DNode temp=dh.next;
        
        int count=0;
        DNode counter=dh.next;
        
        while(counter != dh){
          count++;
          counter=counter.next;
        }
        
        for(int i=0; i<count; i++){
          DNode NN=temp.next;
            if (!((int) temp.elem >= start && (int) temp.elem <= end)) {
                temp=temp;
                //continue;
                  
            }
            else{
                DNode l=dh.prev;
                temp.prev.next = temp.next;
                temp.next.prev = temp.prev;
                
                
                
                temp.next=dh;
                temp.prev=l;

                l.next=temp;
                dh.prev=temp;
                //temp=temp.next;
            }
            temp=NN;
        }
    }